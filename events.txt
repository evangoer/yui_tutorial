.. _events:

******
Events
******

.. TODO 
	- node.on('click', handler);
	- node.delegate('click', handler);
	- Y.on('click', handler, '#someid');
	
	Consistent interface
	Can delegate events
	Can subscribe ahead of DOM availability
	
	From Luke's slides
		// override form behavior
		node.on("submit", function(e) {
			e.preventDefault();
			this.addClass("submitted");  // 'this' is the node (as one might hope). Can set 'this' in the handler.
		});
		// can create synthetic events such as "outsideclick"  -- too advanced for tutorial?
		
	Y.one('#demo').delegate('click', function(e) {/*handle click*/}, 'li');
	
	Ryan Grove's reasons why he likes YUI3 events > other libraries:  DOM events, custom events, synthetic events, delegation, bubbling, plus consistent API and event facades.


    From the YUI training slides:
	
	We've already seen subscribing to events with node.on()
	
	var button = Y.one("#go"); 
	function callback(e) { 
	    Y.log("Hello, World!"); 
	} 
	button.on("click", callback);
	
	or we can skip a step and just use Y.on()
	
	function callback(e) { 
	    Y.log("Hello, World!"); 
	} 
	Y.on("click", callback, "#go");
	
	cover special events:	
	
	Y.on("available", nodeReady, "#image"); 
	Y.on("contentready", childrenReady, "#container");
	
	- goal: assist progressive enhancement, add behavior only when the element is available in the DOM
	- available: define a function to execute as soon as element is detected in the DOM. Don't use for elements that *might* be in the document eventually, just for elements that are in the process of loading.
	- contentready: same as available, except that it waits for the target element and its next sibling.
	
	
	Y.on("domready", domReady); 
	
	- define a function to execute as soon as the DOM is in a usable state = structurally complete. Inserting information into the DOM before the DOM is complete can lead to crashes. DOM is ready before images are loaded.
	
	
	Functions:

	Already seen preventDefault. Talk about e.halt() =  e.stopPropagation() and e.preventDefault(). Talk about bubbling.

	Show that the 'this' in the callback is the node 
	function callback(e) { 
	    // this === commentInput 
	    Y.log( this.get("value") ); 
	} 
	var commentInput = Y.one("#comment"); 
	commentInput.on("blur", callback);
	
	
	show difference between e.target and e.currentTarget
		
	Implement the Asteroids bookmarklet in one line of code!  http://erkie.github.com/ (well, not really)
	function byebye(e) { 
	    e.target.remove(); 
	}
	Y.one("#targets").on("click", byebye);
	
	
	
	From the Event page:
	
	How to remove events? Call detach. Talk about event categories
	- can detach if you have the handle (either fooHandle.detach() or Y.detach(fooHandle))
	- can detach all events of a certain category AND event type
	- can purge all events from an element (optionally including type and recursing to children)
	
	Event Simulation
	
	- node.simulate("mousemove" { clientX: 200, clientY: 200})
	- node.simulate("click", { ctrlKey: true})
	- talk about why you would want to do this. Testing? 
	
	Delegation
	
	- Single handler on a parent element listens for interactions on descendant elements
	- Y.delegate("click", fn, id, optional-selector )
	- or Y.one(node).delegate("click", fn, optional-selector)
	
	function byebye(e) { 
	    this.remove(); 
	} 
	var targets = Y.one("#targets"); 
	targets.delegate("click", byebye, "p");
	
	Touch events!
	- touchstart, touchmove, touchend, touchcancel
	- watch Mark Kawakami's talk for important tidbits
	
	
	Synthetic events!
	- events that work across touch and mouse devices
	- event-flick, event-move
	- Can create synthetic events (worth mentioning, but seems rather advanced)
	
	
	Custom events
	- perhaps worth mentioning, probably too advanced
	